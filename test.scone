module myModule;

def dot[T](a: var Vec2[T], b: var Vec2[T]) -> T {
  const result: T = a.x * b.x + a.y * b.y;
  return result;
};
def plus[T](a: var Vec2[T], b: var Vec2[T]) -> Vec2[T] {
  var result: Vec2[T];
  for idx in 0 until 2 {
    #if idx == 0 {
    #  result.x = 
    #} else {
    #}
    result.at(idx) = a.at(idx) + b.at(idx);
  }
};

def at[T](self: var Vec2[T], idx: u32) -> var T {
  if idx == 0 {
    return self.x;
  } else {
    return self.y;
  }
};
def sum[T](toSum: var array[8 * 3; Vec2[T]]) -> Vec2[T] {
  var result: Vec2[T];

  #for idx in 0 until 2 {
  #  result.at(idx) = T(0);
  #}

  for jdx in 0 until 8 * 3 {
    #for idx in 0 until 2 {
    #  result.at(idx) = 
    #}
    if jdx == 0 {
      for idx in 0 until 2 {
        result.at(idx) = toSum(0).at(idx);
      }
    } else {
      result = result.plus(toSum(jdx));
    }
  }
};
def sum[T](toSum: var array[8 * 3; Vec2[T]]) -> Vec2[T] {
  var result: Vec2[T];

  #for idx in 0 until 2 {
  #  result.at(idx) = T(0);
  #}

  for jdx in 0 until 8 * 3 {
    #for idx in 0 until 2 {
    #  result.at(idx) = 
    #}
    if jdx == 0 {
      for idx in 0 until 2 {
        result.at(idx) = toSum(0).at(idx);
      }
    } else {
      result = result.plus(toSum(jdx));
    }
  }
};
#def sum[T](toSum: var Vec2[T]) -> T {
#  return toSum.x + toSum.y;
#};

struct Vec2[T] {
  x: T;
  y: T;
};

#struct Vec2Ptr[T] {
#  x: ptr T;
#  y: ptr T;
#};
#struct Vec2Arr3[T] {
#  x: array[3; Vec2[T]];
#  y: array[3; Vec2[T]];
#};

#def testFunc[T](a: var Vec2[T], b: var Vec2[T]) -> T {
#  for idx in 0 to 1 {
#    if idx == 0 {
#      
#    } else {
#    }
#  }
#  ##const result: T = a.x * b.x + a.y * b.y;
#  #const result: T = a.dot[T](b=b);
#  #var c: i32 = (d.c.e.g + a) * b;
#  #c = -(- d@);
#  #a.b();
#  #var x: i32 = d.b[g](asdf=asdf) + c * 3;
#  ##--------
#  #if asdf {
#  #  switch addr result {
#  #  case T(3) {
#  #  }
#  #  case T(5) {
#  #    var d: i32 = 3;
#  #    d += 8;
#  #  }
#  #  default {
#  #  }
#  #  }
#  #}
#  ##--------
#  #if result == T(3) {
#  #  if a.dot(b) == 8 {
#  #    return T(5);
#  #  } elif asdf == 8 {
#  #    return 8;
#  #  } else {
#  #    return aaaa;
#  #  }
#  #} elif result == T(2) {
#  #  return T(3);
#  #} elif result == T(5) {
#  #  while yoshi.throw {
#  #  }
#  #} elif result == 3 {
#  #} else {
#  #  return T(25);
#  #}
#  #for i in 0 until 3 {
#  #  const a: i32 = 5;
#  #  while (b + c.d@) {
#  #  }
#  #}
#  #return result;
#};
#--------


#a.plus(b).c(d)


#d.e[ptr ptr array[3; ptr ptr ptr i32]]() + a.plus[T=array[3; i32]](b)




#3 + 4 + (c) method[T](a=3 plus 4, b=c) * b * (6 + 5)
#(3 plus 4) times (8 plus a)

#d.plus(b).c(aaa)
#(d.plus(b).c(aaa)) + (d plus b c aaa)
#d.plus(b) minus c
#d.plus(b.minus(ccc=aaa))
#a.plus b.x(e minus c times d)
#d.plus.b minus c(3.plus)
#d plus b
#3 + 4 + 5

#(3@ + a)@
#(a).b(d) #b[T](a, c)

#def plus(left: i32, right: i32) -> i32 {
# #return left + right;
#};
#
#struct Temp {
# x: array[a plus c; u32];
#};
