module test;

#def dot[T](a: var array[plus(a, b=c); Vec2[T=U]], b: array[3; Vec2[D=T]]) -> T {
#	#return a.x * b.x + a.y * b.y;
#};

#def dot[T](a: Vec2[T], b: array[3 * f 4 ; Vec2[T]]) -> T {
#	#return a.x * b.x + a.y * b.y;
#};
#
#struct Vec2[T] {
#	x: ptr D[A, B];
#	y: T;
#};

def dot[T](a: var Vec2[T], b: var Vec2[T]) -> T {
	const result: T = a.x * b.x + a.y * b.y;
	return result;
};

def testFunc[T](a: var Vec2[T], b: var Vec2[T]) -> T {
	#const result: T = a.x * b.x + a.y * b.y;
	const result: T = a.dot[T](b);
	#--------
	switch result {
	case T(3) {
	}
	case T(5) {
	}
	default {
	}
	};
	#--------
	if result == T(3) {
		return T(5);
	} elif result == T(2) {
		return T(3);
	} elif result == T(5) {
		#
	} else {
		return T(25);
	};
	return result;
};
struct Vec2[T] {
	x: T;
	y: T;
};
#--------


#a.plus(b).c(d)


#d.e[ptr ptr array[3; ptr ptr ptr i32]]() + a.plus[T=array[3; i32]](b)




#3 + 4 + (c) method[T](a=3 plus 4, b=c) * b * (6 + 5)
#(3 plus 4) times (8 plus a)

#d.plus(b).c(aaa)
#(d.plus(b).c(aaa)) + (d plus b c aaa)
#d.plus(b) minus c
#d.plus(b.minus(ccc=aaa))
#a.plus b.x(e minus c times d)
#d.plus.b minus c(3.plus)
#d plus b
#3 + 4 + 5

#(3@ + a)@
#(a).b(d) #b[T](a, c)

#def plus(left: i32, right: i32) -> i32 {
#	#return left + right;
#};
#
#struct Temp {
#	x: array[a plus c; u32];
#};
